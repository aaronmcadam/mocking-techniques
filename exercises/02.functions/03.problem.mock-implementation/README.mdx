# Mock implementation

Mock implementation (`.mockImplementation()`, etc). + `.vi.resetAllMocks()` / `vi.restoreAllMocks()`.

You can also _change_ a behavior of a mock function between tests:

```ts
// Initial function mock.
const fn = vi.fn()

afterEach(() => vi.resetAllMocks())

// The first test runs using the initial mock.
test('first', () => fn())

// The second test provides an implementation override
// for the mock so it behaves differently.
test('second', () => {
  fn.mockImplementation(() => 1)
})
```

> [!] `vi.fn(impl)` is a shorthand for `vi.fn().mockImplementation(impl)`.

> `.mockImplementation()` is usually for the things you don't control directly (a dependency code) or at all (a third-party dependency).

```ts
import { CartService } from '~/services/cart'
import { UserService } from '~/services/user'

test('throws an error when adding to the cart as unauthorized user', () => {
  // Running the actual check is irrelevant for the CartService.
  // It only cares about the result to set it into the right state.
  vi.spyOn(UserService, 'isAuthenticated').mockImplementation(() => false)
})

// Here, another test that needs a different implementation.
// This teaches about ".resetAllMocks()".
// ...
```

> This is way too close to the implementation detail detesting to my liking. At the same time, this is probably a viable strategy for test setup that depends on other modules.
