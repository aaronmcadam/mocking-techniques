# Dependency injection

First, let's take a look at the alternative you can use to module mocking called _dependency injection_.

Dependency injection (short, DI) is a software design technique that reserves the dependency relation, making the system a function of a dependency.

Consider this implementation of a `NotificationService` class:

```ts
import { EmailService } from './email-service.js'

export class NotificationService {
  constructor() {
    this.emailService = new EmailService()
  }

  public async sendEmail(options: SendEmailOptions) {
    this.emailService.send(options)
  }
}
```

To implement its `.sendEmail()` method, the class creates an internal `EmailService` instance and uses it to send emails. The `NotificationService -> EmailService` dependency is _internal_, which means that the consumer of the class doesn't know that such a dependency exists.

Because of this internal nature, the two classes become tightly coupled. If you wished to exclude the `EmailService` behaviors from a `NotificationService` test, you would have to leak the fact of their dependency into the test suite. That is not ideal and must be avoided.

You can avoid it by rewriting the `NotificationService` class to _accept_ an instance of the `EmailService` class as an argument:

```ts add=4 remove=5
import { EmailService } from './email-service.js'

export class NotificationService {
  constructor(private emailService: EmailService) {
    this.emailService = new EmailService()
  }

  public async sendEmail(options: SendEmailOptions) {
    this.emailService.send(options)
  }
}
```

This act of "lifting the dependency up" allows the consumer to provide an instance of the email service when creating a notification service class:

```ts highlight=2
const emailService = new EmailService()
const notifications = new NotificationService(emailService)
```

Dependency injection transforms a `NotificationService -> EmailService` dependency into a notification service class being a _function of the email service_ (`NotificationService = fn(EmailService)`).

That is also rather handy when testing!

Since the `NotificationService` accepts its dependency as an argument now, that dependency is no longer an internal implementation detail but rather a part of its public API. And since it's public, you can exclude that dependency altogether by constructing a _matching object_ in its stead, thus isolating the notifications manager's behavior in the test.

```ts
const mockEmailService = new MockEmailService()
const notifications = new NotificationService(new MockEmailService())
```

The `MockEmailService` in this example is also known as a _fake_ object. In this exercise, you will learn how to construct such fake objects and use them to model different scenarios of the tested system. But first, I have to give you a warning...

## :warning: When to use Dependency injection

**Dependency injection is a software design technique, not a testing technique**. I find it extremely harmful to base your design decisions around how your system is going to be tested. You are creating APIs for your _consumers_, and as such, you must have the consumer's best interest in mind when crafting those APIs. Sometimes that will mean more complexity for you to tackle in tests, and that is perfectly fine.

In other words, be cautious not to rewrite your code for the sake of easier testing experience. This workshop alone gives you enough tools to tackle any complexity your system may introduce. **Let it not sway you from the correct API decisions**.

<callout-info class="important">Design your software for the _user_, not the tests.</callout-info>

## Your task

In this exercise, the `NotificationService` class happened to be written with the dependency injection pattern in mind, and you will certainly use that to your advantage when testing it!

üë®‚Äçüíº Complete the tests for the <InlineFile file="notification-service.test.ts" /> by constructing a fake `EmailService` and using it as an argument to test different notification scenarios.

Once you are done, run `npm test` to make sure that all the tests are passing.
