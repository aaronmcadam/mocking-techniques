# Fakes

1. Fakes (with Dependency injection). Don't focus on DI because it's _not_ exclusively a testing technique. We can still showcase how it helps with testing.

- ðŸ“œ **Article: Good Code Is Testable Code**.

```ts
// Use "implements" for type-safety and compatibility
// with the actual class we are trying to fake.
class FakeDatabase implements Database {
  users: Array<string> = []

  // Implement one of the Database methods
  // but make it simpler. Same behavior, different
  // implementation.
  public addUser(email: string) {
    if (!this.users.includes(emails)) {
      this.users.push(email)
    }
  }
}

test('sends an email', () => {
  // Create a fake database and provide it to the
  // email service so it's used in the test.
  // The email service calls "db.addUser()" internally.
  const database = new FakeDatabase()
  const emailService = new EmailService(database)

  const result = await emailService.sendEmail({
    to: 'kody@epicweb.dev',
    subject: 'Hello!',
  })

  // Must send the email.
  expect(result.sent).toBe(true)
  // Must store the recepient's email address.
  expect(database.users).toEqual(['kody@epicweb.dev'])
})
```

> NOTE: We mustn't assert that `database.addUser()` has been called! That's an implementation detail. Instead, assert on the database state, which is `database.users`.
